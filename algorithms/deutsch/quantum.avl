-[
Quantum solution to the Deutsch's problem.

- author     ntwali bashige
- copyright  2018 (c) ntwali bashige
- license    MIT license
]-

import io
import quant


-- Oracle for f0
def f0 = (val input : ref qubit, val ancilla : ref qubit) -> void:
    Quant.id(input)
    Quant.id(ancilla)
    return


-- Oracle for f1
def f1 = (val input : ref qubit, val ancilla : ref qubit) -> void:
    Quant.cx(input, ancilla)
    return


-- Oracle for f2
def f2 = (val input : ref qubit, val ancilla : ref qubit) -> void:
    Quant.cx(input, ancilla)
    Quant.px(ancilla)
    return


-- Oracle for f3
def f3 = (val input : ref qubit, val ancilla : ref qubit) -> void:
    Quant.px(ancilla)
    return


def __main__ = (val args : [string]) -> void:
    val input = 0q0, ancilla = 0q1

    -- step 1 : apply the Hadamard gate to both the input and the ancilla
    Quant.had(ref input)
    Quant.had(ref ancilla)

    -- step 2 : call the oracle
    f0(ref input, ref ancilla)

    -- step 3 : apply the Hadamard gate to the input
    Quant.had(ref input)

    -- step 4 : measure the input
    val answer = cast(ref input) -> bit

    -- Print the result
    if answer == 0b0:
        Io.println("The oracle contains a constant function.")
    else:
        Io.println("The oracle contains a balanced function.")

    -- we are done
    return
